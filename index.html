<!DOCTYPE html>
<html lang="en">
<head>
    <title>Memory Traces v24</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            overflow: hidden;
            height:100vh;
        }

        canvas {
            display: block;
            position: absolute;
            outline:0;
        }

        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
        }

        /* Log panel styles */
        #logPanel {
            position: absolute;
            left: 10px;
            bottom: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 200px;
            background-color: rgba(0,0,0,0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 4px;
            overflow-y: auto;
            z-index: 1000;
            display: block; /* Changed from 'none' to display by default */
        }

        .logEntry {
            margin: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .logAddress {
            color: #ff0;
            font-weight: bold;
        }

        .logSuccess {
            color: #0f0;
            font-weight: bold;
        }

        .logError {
            color: #f00;
            font-weight: bold;
        }

        .logWarning {
            color: #ff8800;
            font-weight: bold;
        }

        #toggleLog {
            position: absolute;
            left: 10px;
            bottom: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
        }
    </style>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
    <meta itemprop="name" content="Memory Traces v24">
    <meta itemprop="description" content="made with cables">
    <meta itemprop="image" content="screenshot.png">
    <meta name="description" content="made with cables"/>

    <!-- Import map for LUKSO UP Provider -->
    <script type="importmap">
        { "imports": { "@lukso/up-provider": "https://cdn.jsdelivr.net/npm/@lukso/up-provider@0.3.5/dist/index.mjs" } }
    </script>
</head>
<body>
    <canvas id="glcanvas" width="100vw" height="100vh" tabindex="1"></canvas>
    <div id="status">Loading...</div>
    
    <!-- Debug log panel - now shown by default -->
    <button id="toggleLog">Hide Debug Log</button>
    <div id="logPanel"></div>
    
    <!-- Create global variables to store connection information -->
    <script>
        // Global namespace for our integration
        window.LUKSO_INTEGRATION = {
            upAddress: null,
            addressUpdated: false,
            debug: true,
            initTime: Date.now(), // Add initialization timestamp
            
            // Visual logging system
            logPanel: null,
            logEntries: [],
            maxLogEntries: 100, // Increased from 50
            
            // Initialize logging
            initLogging: function() {
                this.logPanel = document.getElementById('logPanel');
                const toggleButton = document.getElementById('toggleLog');
                
                toggleButton.addEventListener('click', () => {
                    if (this.logPanel.style.display === 'none') {
                        this.logPanel.style.display = 'block';
                        toggleButton.textContent = 'Hide Debug Log';
                    } else {
                        this.logPanel.style.display = 'none';
                        toggleButton.textContent = 'Show Debug Log';
                    }
                });
                
                // Add initial log entry with timestamp
                this.log(`Logging system initialized (${new Date().toISOString()})`);
            },
            
            // Enhanced log function with timestamps
            log: function(msg, type = 'info') {
                const timestamp = Date.now();
                const elapsed = timestamp - this.initTime;
                const timeString = `[+${elapsed}ms]`;
                
                if (this.debug) console.log(`[LUKSO] ${timeString} ${msg}`);
                
                // Add to visual log
                if (this.logPanel) {
                    // Create log entry
                    const entry = document.createElement('div');
                    entry.className = 'logEntry';
                    
                    if (type === 'address') {
                        entry.innerHTML = `${timeString} <span class="logAddress">▶ UP Address: ${msg}</span>`;
                    } else if (type === 'success') {
                        entry.innerHTML = `${timeString} <span class="logSuccess">✓ ${msg}</span>`;
                    } else if (type === 'error') {
                        entry.innerHTML = `${timeString} <span class="logError">✗ ${msg}</span>`;
                    } else if (type === 'warning') {
                        entry.innerHTML = `${timeString} <span class="logWarning">⚠ ${msg}</span>`;
                    } else if (type === 'raw') {
                        // For raw data dumps
                        entry.innerHTML = `${timeString} <pre>${JSON.stringify(msg, null, 2)}</pre>`;
                    } else {
                        entry.textContent = `${timeString} ${msg}`;
                    }
                    
                    // Add to panel
                    this.logPanel.appendChild(entry);
                    this.logEntries.push(entry);
                    
                    // Trim old entries
                    if (this.logEntries.length > this.maxLogEntries) {
                        this.logPanel.removeChild(this.logEntries.shift());
                    }
                    
                    // Scroll to bottom
                    this.logPanel.scrollTop = this.logPanel.scrollHeight;
                }
            },
            
            // Function to examine and log patch structure
            inspectPatch: function(patch) {
                this.log("--- PATCH INSPECTION ---");
                
                // Check if patch exists
                if (!patch) {
                    this.log("Patch object is null or undefined!", "error");
                    return false;
                }
                
                // Log patch type
                this.log(`Patch type: ${typeof patch}`);
                
                // Check variables property
                if (patch.variables) {
                    this.log("Patch has 'variables' property");
                    
                    // Log available variables
                    const varNames = Object.keys(patch.variables);
                    this.log(`Found ${varNames.length} variables: ${varNames.join(', ')}`);
                    
                    // Check for Address variable specifically
                    if (patch.variables.Address) {
                        this.log("'Address' variable found!", "success");
                        
                        // Log variable properties
                        this.log(`Address variable type: ${typeof patch.variables.Address}`);
                        if (typeof patch.variables.Address.set === 'function') {
                            this.log("Address variable has set() method", "success");
                        } else {
                            this.log("Address variable missing set() method", "error");
                        }
                        
                        return true;
                    } else if (patch.variables.address) {
                        this.log("Found lowercase 'address' variable", "warning");
                        return true;
                    } else {
                        this.log("No 'Address' variable found in patch", "error");
                    }
                } else {
                    this.log("Patch is missing 'variables' property", "error");
                }
                
                // Check getVar method
                if (typeof patch.getVar === 'function') {
                    this.log("Patch has getVar() method");
                    
                    try {
                        const addrVar = patch.getVar("Address");
                        if (addrVar) {
                            this.log("Successfully retrieved 'Address' using getVar()", "success");
                            return true;
                        } else {
                            this.log("getVar('Address') returned null/undefined", "error");
                            
                            // Try lowercase
                            const addrVarLower = patch.getVar("address");
                            if (addrVarLower) {
                                this.log("Found lowercase 'address' using getVar()", "warning");
                                return true;
                            }
                        }
                    } catch (e) {
                        this.log(`Error using getVar(): ${e.message}`, "error");
                    }
                } else {
                    this.log("Patch is missing getVar() method", "error");
                }
                
                // Try listing all methods
                this.log("Patch methods:");
                for (const prop in patch) {
                    if (typeof patch[prop] === 'function') {
                        this.log(` - ${prop}()`);
                    }
                }
                
                return false;
            }
        };
        
        // Initialize logging system when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            LUKSO_INTEGRATION.initLogging();
        });
    </script>
    
    <!-- Load patch.js file -->
    <script type="text/javascript" src="js/patch.js"></script>
    
    <!-- Standard cables initialization -->
    <script type="text/javascript">
        function showError(initiator,...args) {
            CABLES.logErrorConsole("[" + initiator + "]", ...args);
            LUKSO_INTEGRATION.log(`CABLES Error [${initiator}]: ${args.join(', ')}`, "error");
        }

        function patchInitialized(patch) {
            LUKSO_INTEGRATION.log("Patch initialized - examining patch structure");
            LUKSO_INTEGRATION.inspectPatch(patch);
            LUKSO_INTEGRATION.log("Attempting to update address after init");
            tryUpdateAddress(patch);
        }

        function patchFinishedLoading(patch) {
            LUKSO_INTEGRATION.log("Patch finished loading - examining patch again");
            LUKSO_INTEGRATION.inspectPatch(patch);
            LUKSO_INTEGRATION.log("Attempting to update address after load");
            tryUpdateAddress(patch);
            
            // Also try again after a delay to ensure everything is fully loaded
            setTimeout(() => {
                LUKSO_INTEGRATION.log("Delayed address update attempt (1000ms)");
                tryUpdateAddress(patch);
            }, 1000);
        }
        
        function tryUpdateAddress(patch) {
            LUKSO_INTEGRATION.log("----- UPDATING ADDRESS -----");
            
            if (!LUKSO_INTEGRATION.upAddress) {
                LUKSO_INTEGRATION.log("No UP address available yet", "error");
                return;
            }
            
            LUKSO_INTEGRATION.log(`Attempting to update Address variable with: ${LUKSO_INTEGRATION.upAddress}`);
            
            try {
                // Try direct access to the Address variable
                if (patch.variables && patch.variables.Address) {
                    patch.variables.Address.set(LUKSO_INTEGRATION.upAddress);
                    LUKSO_INTEGRATION.log("Updated Address via patch.variables", "success");
                    LUKSO_INTEGRATION.addressUpdated = true;
                    return true;
                }
                
                // Try using getVar method
                try {
                    const addressVar = patch.getVar("Address");
                    if (addressVar) {
                        addressVar.set(LUKSO_INTEGRATION.upAddress);
                        LUKSO_INTEGRATION.log("Updated Address via patch.getVar", "success");
                        LUKSO_INTEGRATION.addressUpdated = true;
                        return true;
                    }
                } catch (varErr) {
                    LUKSO_INTEGRATION.log(`getVar error: ${varErr.message}`, "error");
                }
                
                // Try with lowercase "address" as well
                try {
                    const addressVarLower = patch.getVar("address");
                    if (addressVarLower) {
                        addressVarLower.set(LUKSO_INTEGRATION.upAddress);
                        LUKSO_INTEGRATION.log("Updated 'address' (lowercase) via patch.getVar", "success");
                        LUKSO_INTEGRATION.addressUpdated = true;
                        return true;
                    }
                } catch (varErr) {
                    LUKSO_INTEGRATION.log(`getVar(lowercase) error: ${varErr.message}`, "error");
                }
                
                LUKSO_INTEGRATION.log("Could not find Address variable in patch", "error");
                return false;
            } catch (err) {
                LUKSO_INTEGRATION.log(`Error updating address: ${err.message}`, "error");
                return false;
            }
        }

        document.addEventListener("CABLES.jsLoaded", function (event) {
            LUKSO_INTEGRATION.log("CABLES.jsLoaded event fired");
            
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                prefixAssetPath: "",
                assetPath: "assets/",
                jsPath: "js/",
                glCanvasId: "glcanvas",
                glCanvasResizeToWindow: true,
                onError: showError,
                onPatchLoaded: patchInitialized,
                onFinishedLoading: patchFinishedLoading,
                canvas: {alpha:true, premultipliedAlpha:true}
            });
        });

        // disable rubberband effect on mobile devices
        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
    </script>
    
    <!-- LUKSO wallet integration -->
    <script type="module">
        import { createClientUPProvider } from '@lukso/up-provider';
        
        // Create the LUKSO UP provider
        const provider = createClientUPProvider();
        const status = document.getElementById('status');
        
        // Log when provider is created
        LUKSO_INTEGRATION.log("UP Provider created", "success");

        async function initWallet() {
            LUKSO_INTEGRATION.log("==== initWallet started ====");
            
            try {
                // Log chain ID request
                LUKSO_INTEGRATION.log("Requesting chain ID...");
                let chainId;
                try {
                    chainId = await provider.request({ method: 'eth_chainId' });
                    LUKSO_INTEGRATION.log(`Chain ID response: ${chainId} (decimal: ${parseInt(chainId, 16)})`, "success");
                } catch (chainErr) {
                    LUKSO_INTEGRATION.log(`Chain ID request failed: ${chainErr.message}`, "error");
                    LUKSO_INTEGRATION.log(chainErr.stack || "No stack trace available");
                }
                
                // Log accounts request
                LUKSO_INTEGRATION.log("Requesting accounts...");
                let accounts;
                try {
                    accounts = await provider.request({ method: 'eth_accounts' });
                    LUKSO_INTEGRATION.log(`Accounts response received with ${accounts.length} accounts`);
                    LUKSO_INTEGRATION.log("Raw accounts response:", "raw");
                    LUKSO_INTEGRATION.log(accounts);
                } catch (acctErr) {
                    LUKSO_INTEGRATION.log(`Accounts request failed: ${acctErr.message}`, "error");
                    LUKSO_INTEGRATION.log(acctErr.stack || "No stack trace available");
                    accounts = [];
                }

                if (accounts && accounts.length) {
                    // Store the UP address
                    LUKSO_INTEGRATION.upAddress = accounts[0];
                    LUKSO_INTEGRATION.log(accounts[0], "address");
                    status.textContent = `Connected: ${accounts[0].substring(0, 6)}...${accounts[0].substring(accounts[0].length - 4)}`;
                    
                    // Try to update the patch if it's already loaded
                    if (window.CABLES && window.CABLES.patch) {
                        LUKSO_INTEGRATION.log("CABLES patch detected, updating address...");
                        tryUpdateAddress(window.CABLES.patch);
                    } else {
                        LUKSO_INTEGRATION.log("CABLES patch not ready yet. Address will be set once patch loads.", "warning");
                    }
                } else {
                    status.textContent = 'Waiting for wallet...';
                    LUKSO_INTEGRATION.log("No accounts found - waiting for wallet connection", "warning");
                    
                    // Try requesting accounts with eth_requestAccounts method
                    LUKSO_INTEGRATION.log("Trying eth_requestAccounts as fallback...");
                    try {
                        const requestedAccounts = await provider.request({ method: 'eth_requestAccounts' });
                        LUKSO_INTEGRATION.log(`eth_requestAccounts returned ${requestedAccounts.length} accounts`);
                        
                        if (requestedAccounts.length > 0) {
                            LUKSO_INTEGRATION.upAddress = requestedAccounts[0];
                            LUKSO_INTEGRATION.log(requestedAccounts[0], "address");
                            status.textContent = `Connected: ${requestedAccounts[0].substring(0, 6)}...${requestedAccounts[0].substring(requestedAccounts[0].length - 4)}`;
                            
                            // Try to update the patch
                            if (window.CABLES && window.CABLES.patch) {
                                tryUpdateAddress(window.CABLES.patch);
                            }
                        }
                    } catch (reqErr) {
                        LUKSO_INTEGRATION.log(`eth_requestAccounts failed: ${reqErr.message}`, "error");
                    }
                }
                
                LUKSO_INTEGRATION.log("==== initWallet completed ====");
            } catch (error) {
                LUKSO_INTEGRATION.log(`Error initializing wallet: ${error.message}`, "error");
                LUKSO_INTEGRATION.log(error.stack || "No stack trace available");
                status.textContent = 'Wallet connection error';
            }
        }

        // Log when setting up event listeners
        LUKSO_INTEGRATION.log("Setting up wallet event listeners");
        
        // Set up event listeners for wallet changes with logging
        provider.on('accountsChanged', (accounts) => {
            LUKSO_INTEGRATION.log(`accountsChanged event fired with ${accounts ? accounts.length : 0} accounts`);
            initWallet();
        });
        
        provider.on('chainChanged', (chainId) => {
            LUKSO_INTEGRATION.log(`chainChanged event fired: ${chainId}`);
            initWallet();
        });
        
        provider.on('contextAccountsChanged', (accounts) => {
            LUKSO_INTEGRATION.log(`contextAccountsChanged event fired with ${accounts ? accounts.length : 0} accounts`);
            initWallet(); 
        });

        // Initialize wallet with delay to ensure DOM is ready
        setTimeout(() => {
            LUKSO_INTEGRATION.log("Calling initWallet after short delay");
            initWallet();
        }, 100);
    </script>
</body>
</html>